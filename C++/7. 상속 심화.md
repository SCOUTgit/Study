# __7.1 가상함수__
- 가상함수는 virtual 예약어를 앞에 붙여서 선언한 메서드이다.
- 파생 형식에서 메서드를 재정의하면 과거의 정의가 완전히 무시된다.
---
## 기본문법
```C++
virtual 반환형식 메서드이름
```
- 가상함수는 일반 메서드와 달리 참조 형식이 무엇이든 실 형식의 메서드를 호출한다.
- 부모 클래스에서 가상 함수를 호출한다면 파생클래스의 재정의 된 가상함수를 호출한다.
---
## 소멸자 가상화
- 상위 클래스로 하위 파생 클래스를 참조할 때 상위 클래스 형식을 추상 자료형이라고한다.
- 추상 자료형을 이용해 동적 생성한 객체를 참조할 경우 파생 형식의 소멸자가 호출되지 않기 때문에 심각한 메모리 누수 오류가 발생할 수 있다.
- 이 문제를 해결하기 위해 소멸자를 가상화한다.
- 소멸자를 가상화하면 파생 클래스의 소멸자까지 제대로 호출된다.
---
# __7.2 가상 함수 테이블__
- 가상 함수 테이블은 함수 포인터 배열이라고 볼 수 있다.
- this 포인터 아래에 있는 __vfptr이라는 지역변수는 가상 함수 테이블의 포인터이다
- __vfptr을 따라가면 가상 함수로 선언된 멤버 함수들의 주소에 배열 형태로 접근할 수 있다.
- __vfptr의 값은 파생 형식 생성자가 호출되는 순간 파생 클래스에 맞춰 자동으로 변경된다.
- __vfptr은 마지막에 파생된 클래스의 가상 함수 테이블 값으로 덮어씌워지므로 접근 형식에 상관없이 실 형식의 함수가 호출된다.
- 바인딩이란 함수나 변수의 주소가 결정되는 것을 말한다.
- 주소가 컴파일 타임에 결정되면 이른 바인딩이고 빌드한 프로그램이 실행되는 도중에 주소가 결정되면 늦은 바인딩(동적 바인딩)이다.
- 가상함수는 프로그램이 실행되는 도중에 주소가 결정되므로 늦은 바인딩이다.
---
# __7.3 순수 가상 클래스__
- 순수 가상 클래스는 순수 가상 함수를 멤버로 가진 클래스를 말한다.
- 순수 가상 함수는 선언은 해두지만 정의는 파생 클래스에서 정의하는 함수이다.
- 순수 가상 함수를 선언할 때 끝부분에 '= 0' 이 붙는다.
```C++
virtual 반환형식 함수이름(매개변수) = 0;
```
- 순수 가상 클래스는 인스턴스를 직접 선언할 수 없다.
- 순수 가상 클래스의 파생 클래스는 반드시 기본 클래스의 순수 가상 함수를 재정의해야 한다.
---
# __7.4 상속과 형변환__

형변환 연산자|설명
---|---
const_cast<>|상수형 포인터에서 const를 제거합니다.
static_cast<>|컴파일 시 상향 혹은 하향 형변환합니다.
dynamic_cast<>|런타임 시 상향 혹은 하향 형변환합니다.
reinterpret_cast<>|C의 형변환 연산자와 흡사합니다.
---
## static_cast
- 상속 관계일 때 파생 형식을 기본 형식으로 포인팅 하는 경우를 상향 형변환이라고 한다.
- 상속 관계일 때 기본 형식 포인터가 가리키는 대상을 파생 형식 포인터로 형변환 하는 경우를 하향 형변환이라고 한다.
- static_cast를 통해서 형변환을 할 때 형변환 연산자의 피연산자는 반드시 괄호로 묶어야 한다.
- 문법적으로 적절한 상향 혹은 하향 형변환이 아니라면 컴파일 오류가 발생한다.
---
## dynamic_cast
- 동적으로 생성된 객체를 가리키는 포인터가 기본 형식일 때 구체적으로 어떤 객체에 대한 인스턴스인지 확인할 때 dynamic_cast가 쓰인다.
- dynamic_cast 연산자는 형변환에 실패하면 NULL을 반환하는데 이를 이용해서 바른 변환인지 아닌지를 확인할 수 있다.
- dynamic_cast가 꼭 필요한 경우가 아니라면 절대로 dynamic_cast는 사용하지 말아야 한다.
---
# __7.5 상속과 다중정의__
- 파생 클래스에서는 기본 클래스가 가진 생성자를 그대로 지원하고 싶다면 일일이 맞추어 똑같이 정의해야한다.
- 기본적으로 모든 연산자는 파생 형식에 자동으로 상속된다고 볼 수 있지만 단순 대입 연산자는 그렇지 않다.
- 생성자 상속처럼 using 키워드를 이용하면 한번에 해결이 가능하다.
```C++
class 파생클래스이름 : 접근제어지시자 부모클래스이름
{
public:
    using 클래스이름::operator연산자;
};
```
---
# __7.6 다중 상속__
- 다중 상속은 한 클래스가 두 개 이상의 클래스를 동시에 상속받는 경우이다.
```C++
class 파생클래스이름 : 접근제어지시자 부모클래스이름1, 부모클래스이름2, ...
```
---
## 다중 상속과 모호성
- 두 개 이상의 부모클래스에 같은 이름의 함수가 호출된다면 모호성으로 인하여 오류가 발생한다.
- 이 오류는 묵시적인 호출이 아니라 명시적인 호출로 해결할 수 있다.
---
## 가상 상속
- 다중 상속을 받을 때 부모 클래스들이 같은 클래스를 상속받은 경우 생성자가 여러번 호출된다.
- 생성자가 여러번 호출되는 것을 막기 위해 가상 상속을 적용한다.
- 가상 상속은 상속 코드를 작성할 때 파생 형식 클래스에 virtual 예약어를 함께 선언해준다.
