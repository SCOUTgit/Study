# __2.1 디폴트 매개변수__
```C++
반환 자료형 함수이름(매개변수자료형이름 = 디폴트값);
```
- 매개변수의 디폴트 값을 선언한 함수는 호출자 코드에서 실인수를 생략한 채 호출할 수 있다.
- 피호출자 함수 매개변수의 디폴트 값은 반드시 오른쪽 매개변수부터 기술해야한다.
- 매개변수가 여러 개일 때 왼쪽 첫 번째 매개변수의 디폴트 값을 기술하려면 나머지 오른쪽 모든 매개변수에 대한 디폴트 값을 기술해야 한다.
- 호출자 함수가 피호출자 함수 매개변수의 실인수를 기술하면 이는 왼쪽부터 짝을 맞추어 적용되며, 짝이 맞지 않는 매개변수는 디폴트 값을 적용한다.
+ 예시
```C++
int TestFunc1(int nParam = 10){
    return nParam
}
int TestFunc2(int nParam1, nParam2 = 10){
    return nParam1 + nParam2;
}
int TestFunc3(int nParam1 = 20, nParam2, nParam3 = 10){  // 오류 발생
    return nParam1 + nParam2 + nParam3;
}

int main(){
    std::cout<<TestFunc1()<<std::endl;
    std::cout<<TestFunc1(20)<<std::endl;
    std::cout<<TestFunc2(20)<<std::endl;
    std::cout<<TestFunc2(10, 30)<<std::endl;
    return 0;
}
```
---
# __2.2 함수 다중 정의__
- 다중 정의는 함수 이름이나 변수 이름 등이 여러 의미를 동시에 갖는 것을 뜻한다.
- Overloading이라고 불린다.
- 이를 통해 C++은 함수의 다형성을 지원한다.
## 다중 정의 일반
- 함수의 이름이 같은 경우 함수의 매개변수 구성이 다를 경우 다중 정의가 가능하다.
- 반환 형식만 다르거나 호출 규칙만 다른 경우에는 다중 정의가 불가능하다.
+ 예시
```C++
int Add(int a, int b, int c){
    return a + b + c;
}

int Add(int a, int b){
    return a + b;
}

double Add(double a, double b){
    return a + b;
}

int main(){
    std::cout<<Add(1, 2)<<std::endl;
    std::cout<<Add(1, 2, 3)<<std::endl;
    std::cout<<Add(1.1, 2.2)<<std::endl;
    return 0;
}
```
---
## 다중 정의와 모호성
- 디폴트 매개변수와 다중 정의가 조합되었을 때 모호성이 발생할 수 있다.
+ 예시
```C++
void TestFunc(int a){
    std::cout << a << std::endl;
}

void TestFunc(int a, int b = 10){
    std::cout << a + b << std::endl;
}

int main(){
    TestFunc(1);    // 오류 발생 (오버로드된 함수에 대한 호출이 모호하다.)
    return 0;
}
```
---
## 함수 템플릿
```C++
- 함수 템플릿을 이용하면 다양한 자료형의 매개변수를 가진 오버로드된 함수를 하나로 간추릴 수 있다.
template <typename T>   // T : 자료형
반환형식 함수이름(매개변수){

}
```
+ 예시
```C++
template <typename T>
T Add(T a, T b){
    return a + b
}

int main(){
    std::cout << Add(1, 2) << std::endl;
    std::cout << Add<int>(1, 2) << std::endl;
    std::cout << Add(1.1, 2.2) << std::endl;
    return 0;
}
```
---
# 2.3 인라인 함수
- 인라인 함수는 일반적인 함수처럼 매개변수에 형식을 지정할 수 있고 매크로처럼 내부적으로 함수 호출을 하지 않는다.
- 문법은 함수 원형 앞에 inline이라는 예약어만 작성하면 된다.
+ 예시
```C++
inline int Add(int a, int b){
    return a + b;
}
```
---
# 2.4 네임스페이스
- 네임스페이스는 C++이 지원하는 각종 요소들을 한 범주로 묶어주기 위한 문법이다.
- 네임스페이스를 선언하려면 namespace 예약어를 이용해서 선언한다.
```C++
namespace 이름{
    
}
```
- 네임스페이스에서 선언한 변수나 함수는 모두 해당 네임스페이스에 속한다.
- 변수나 함수에 네임스페이스가 존재할 경우 식별자 앞에 범위지정연산자(::)를 이용해 네임스페이스를 기술할 수 있다.
```C++
네임스페이스 이름::변수이름
네임스페이스 이름::함수이름
```
## using 선언
- 네임스페이스를 경우에 따라 생략해야하는데 이 때 using이라는 예약어가 사용된다.
```C++
using namespace 네임스페이스이름;
```
---
## 네임스페이스의 중첩
- 네임스페이스 안에 또 다른 네임스페이스가 속할 수 있다.
- 여러개의 네임스페이스가 동시에 속할 수 있고 속한 네임스페이스 안에 또 다른 네임스페이스가 속할 수 있다.
---
## 네임스페이스와 다중 정의
- 함수 이름과 매개변수 구성이 같아도 네임스페이스가 같으면 다중 정의가 가능하다.
- 하지만 다중 정의한 함수들이 속한 네임스페이스들을 using을 이용해 생략한다면 모호성이 의해서 오류를 발생시킨다.
---
# __2.5 식별자 검색 순서__
## 전역함수인 경우
1. 현재 블록 범위
2. 현재 블록 범위를 포함하고 있는 상위 블록 범위(최대 적용 범위는 함수 몸체까지)
3. 가장 최근에 선언된 전역 변수나 함수
4. using 선언된 네임스페이스 혹은 전역 네임스페이스 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생
## 클래스 메서드인 경우
1. 현재 블록 범위
2. 현재 블록 범위를 포함하고 있는 상위 블록 범위(최대 적용 범위는 함수 몸체까지)
3. 클래스의 멤버
4. 부모 클래스의 멤버
5. 가장 최근에 선언된 전역 변수나 함수
6. 호출자 코드가 속한 네임스페이스의 상위 네임스페이스
7. using 선언된 네임스페이스 혹은 전역 네임스페이스 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생