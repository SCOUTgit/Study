# __6.1 상속이란?__
- 상속은 객체 단위 코드를 재사용하는 방법이며, 재사용이란 기능적 확장이나 개선을 의미한다.
---
## 기본 문법
```C++
class 파생클래스이름 : 접근제어지시자 부모클래스이름
```
- 상속을 받는 클래스는 파생 클래스라고 부르고 상속을 하는 클래스는 부모 클래스라고 부른다.
- 파생 클래스의 인스턴스가 생성될 때 기본 클래스의 생성자도 호출된다.
- 파생 클래스는 기본 클래스의 멤버에 접근할 수 있다. 단, private 접근 제어 지시자로 선언된 클래스 멤버에는 접근할 수 없다.
- 사용자 코드에서는 파생 클래스의 인스턴스를 통해 기본 클래스 메서드를 호출할 수 있다.
+ 생성자 호출 순서
1. 파생 클래스 생성자 호출
2. 상위 클래스 생성자 호출
3. 상위 클래스 생성자 실행 및 반환
4. 파생 클래스 생성자 실행 및 반환
---
# __6.2 메서드 재정의__
- 파생 클래스에서 기본 클래스의 메서드를 재정의하면 기존의 것은 무시되고 새로 정의된 것이 기존의 것을 대체한다.
- Overriding이라고 불린다.
---
## 기본 문법 및 특징
- 예시
```C++
#include <iostream>
using namespace std;

class CMyData
{
public:
    int GetData(){ return m_nData; }
    void SetData(int nParam) { m_nData = nParam; }
private:
    int m_nData = 0;
};

class CMyDataEx : public CMyData
{
public:
    void SetData(int nParam)    // 부모 클래스의 SetData 메서드 재정의
    {
        if(nParam < 0)
            CMyData::SetData(0);
        
        else if(nParam > 10)
            CMyData::SetData(10);
        
        else
            CMyData::SetData(nParam);
    }
};

int main()
{
    CMyData a;
    a.SetData(-10);

    CMyData b;
    b.SetData(15);

    return 0;
}
```
- 파생 형식에서 기본 형식의 동일한 메서드를 호출하려면 반드시 이와 같이 소속 클래스를 명시해야 한다.
- 상속과 재정의의 가장 보편적인 목적은 기존 메서드와 새 메서드를 한데 묶어 작동하게 하기 위함이다.
---
## 참조 형식과 실 형식
- 파생 형식을 기본 형식으로 참조할 수 있다.
- 실 형식과 참조 형식이 다른 경우 메서드를 호출하면 묵시적인 호출로 참조 형식의 메서드가 호출된다.
---
# __6.3 상속에서의 생성자와 소멸자__
## 호출 순서
- 생성자의 실행 순서는 호출 순서와 역순이고 소멸자의 실행 순서는 호출 순서와 같다.
- 파생 클래스에서 부모 클래스의 멤버 변수에 접근 및 연산은 바람직 하지 않다.
---
## 생성자 선택
- 파생 클래스에서 상위 클래스 생성자는 하나만 선택할 수 있다.
- 생성자 상속을 이용하면 파생클래스를 만들 때 다중 정의된 상위 클래스의 생성자들을 그대로 가져온다.
```C++
class 파생클래스이름 : 접근제어지시자 부모클래스이름
{
public:
    using 클래스이름::생성자;   // 생성자 상속
};
```