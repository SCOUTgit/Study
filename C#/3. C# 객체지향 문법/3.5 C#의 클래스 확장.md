# __C#의 클래스 확장__
## 중첩클래스
- 클래스 내부에 또 다른 클래스를 정의하는 것이다.
```C#
    접근제한자 class 클래스명
    {
        접근제한자 class 중첩클래스명1
        {

        }

        접근제한자 class 중첩클래스명2
        {

        }
    } 
```
---
## 추상 클래스
- 부모 클래스의 인스턴스를 생성하지 못하게 하면서 특정 메서드에 대해 자식들이 반드시 재정의하도록 강제하고 싶을 때 추상 클래스와 추상 메서드가 쓰인다.
- 추상 메서드
    - 추상 메서드는 abstract 예약어가 지정되고 구현 코드가 없는 메서드를 말한다.
    - 추상클래스 안에서만 선언할 수 있다.
    - 자식 클래스에서 재정의해야만 컴파일 된다.
- 추상 클래스
    - 추상 클래스는 abstract 예약어가 지정되고 new를 사용해 인스턴스로 만들 수 없다.
    - 추상 클래스는 추상 메서드를 가질 수 있다.
```C#
   접근제한자 abstract class 추상클래스명
   {
       접근제한자 abstract 반환 타입 추상메서드명(타입 매개변수명);
   }
```
---
## 델리게이트
- 델리게이트는 메서드를 가리킬 수 있는 타입으로 delegate라는 예약어로 표현한다.
- 대상이 될 메서드의 반환 타입 및 매개변수 목록과 일치하는 델리게이트 타입을 정의한다.
```C#
    접근제한자 delegate 대상_메서드의_반환타입 식별자(...대상_메서드의_매개변수_목록...);
```
- 델리게이트는 인스턴스가 메서드를 호출할 수 있다는 점을 제외하고는 완전한 타입에 속한다.
- 메서드의 반환값, 메서드의 인자, 클래스의 멤버로 델리게이트를 사용할 수 있다.
- delegate 예약어가 메서드를 가리킬 수 있는 내부 닷넷 타입(System.MulticastDelegate)에 대한 "간편 표기법"이라는 점에 있다.
- 델리게이트는 '+=', '-=' 연산자를 이용해서 여러개의 메서드를 담을 수 있다.
---
## 콜백 메서드
- 피호출자에서 호출자의 메서드를 호출하는 것을 콜백이라 하고, 역으로 호출된 호출자 측의 메서드를 콜백 메서드라고 한다.
- 콜백 호출 패턴에서 타입 자체를 전달해서 문제가 생기는 것을 방지하기 위해 메서드에 대한 델리게이트를 전달한다.
---
## 인터페이스
- 추상클래스와 비슷한 역할을 한다.
- 인터페이스에는 메서드 선언을 0개 이상 포함할 수 있다.
```C#
    접근제한자 interface 인터페이스명
    {
        // 메서드 선언;
    }
```
- 클래스와는 달리 다중 상속이 가능하다.
- 인스턴스의 메서드를 자식클래스에 구현할 때는 반드시 public 접근제한자를 명시해야 한다.
+ 예제
```C#
    public interface animal
    {
        void move();
    }

    class tiger : animal
    {
        public void move(){
            Console.WriteLine("호랑이가 움직인다.");
        }
    }
```
---
## IEnumerable 인터페이스
```C#
    public interface IEnumerable
    {
        IEnumerable GetEnumerator();
    }
```
- IEnumerable 인터페이스에 정의된 GetEnumerator는 열거자라고 하는 객체를 반환한다.
- 열거자란 IEnumerator 인터페이스를 구현한 객체이다.
```C#
    public interface IEnumerator
    {
        object Current {get;}
        bool MoveNext();
        void Reset();
    }
```
- IEnumerable 인터페이스를 구현한 객체는 foreach를 활용하기 좋다.
---
## 구조체
- 값 형식에 사용자 정의 형식으로 구현할 수 있는 것이 구조체이다.
- 인스턴스 생성을 new로 해도 되고, 안해도 된다.
- 기본 생성자는 명시적으로 정의할 수 없다.
- 매개변수를 갖는 생성자를 정의해도 기본 생성자가 C# 컴파일러에 의해 자동으로 포함된다.
- 매개변수를 받는 생성자의 경우, 반드시 해당 코드 내에서 구조체의 모든 필드에 값을 할당해야 한다.
- 깊은 복사와 얕은 복사
    - 깊은 복사는 인스턴스가 가진 메모리 자체가 복사되어 새로운 변수에 대입되는 것을 뜻한다.
    - 얕은 복사는 참조 형식의 변수가 대입되는 방식을 뜻한다.
---
## 값에 의한 호출
- 변수의 스택 값이 복사되는 상황을 특별히 메서드의 인자 전달과 관련해 값에 의한 호출(CBV : call by value)이라 한다.
---
## 참조에 의한 호출
- 해당 변수의 스택값을 담고 있는 주소 자체를 메서드에 인자로 전달되는 것을 참조에 의한 호출(CBR : call by reference)이라 한다.
---
## ref 예약어
- ref 예약어는 참조에 의한 호출을 위한 예약어이다.
- 메서드의 매개변수를 선언할 때 함께 표기해야 한다.
- 해당 메서드를 호출하는 측에서도 명시해야 한다.
- ref 예약어를 사용하면 메서드의 매개변수가 호출 측의 전달인자와 동일한 주소를 가리키게 된다.
---
## out 예약어
- out으로 지정된 인자에 넘길 변수는 초기화되지 않아도 된다.
- 초기화돼 있더라고 out 인자를 받는 메서드에서는 그 값을 사용할 수 없다.
- out으로 지정된 인자를 받는 메서드는 반드시 변수에 값을 넣어서 반환해야 한다.
- 메서드에서 out예약어를 사용함으로써 여러 개의 값을 반환할 수 있다.
---
## 열거형
- 열거형도 값 형식의 하나로 byte, sbyte short, ushort, int, uint, long, ulong만을 상속받아 정의할 수 있는 제한된 사용자 정의 타입이다.
- enum 타입은 숫자형 값에 사람이 인식하기 쉬운 문자열 이름을 부여한다.
```C#
    [접근제한자] enum 타입명
    {
        // 숫자를 대표하는 식벼랒 이름 나열
    }
```
- enum의 시작 요소 값에 0이 아닌 다른 정수를 지정할 수 있고, 그 이후의 요소에 대해서도 1씩 자동으로 증가하는 것이 아닌 개발자가 임의로 값을 지정할 수 있다.
- [Flags]라는 특성을 enum타입에서만 사용할 수 있다.
```C#
    [Flags]
    [접근제한자] enum 타입명
    {
        // 숫자를 대표하는 식벼랒 이름 나열
    }
```
---
## 읽기 전용 필드
- readonly라는 예약어를 사용하면 클래스 내부에서도 읽기만 가능하게 할 수 있다.
- 읽기 전용 필드는 변수를 정의할 때와 생성자 내부를 제외하고는 그 값을 바꾸는 시도를 할 수 없다.
```C#
    readonly 타입 변수명;
```
---
## 상수
- 변하지 않는 값인 리터럴을 식별자로 재사용할 수 있게 해주는 게 상수이다.
- 중복되는 변수가 있다면 상수를 사용해서 유지보수를 쉽게 할 수 있다.
```C#
    접근제한자 const 상수타입 식별자 = 값;
```
---
## 인덱서
- 인덱서를 이용하면 클래스의 인스턴스 변수에 배열처럼 접근하는 방식의 대괄호 연산자를 사용할 수 있다.
- 프로퍼티를 정의하는 구문과 유사하며, 단지 프로퍼티명이 this 예약어로 대체된다는 점과 인덱스로 별도의 타입을 지정할 수 있다는 점이 다르다.
```C#
    class 클래스명
    {
        접근제한자 반환타입 this[인덱스타입 인덱스식별자]
        {
            접근제한자 get
            {
                // ...코드...
                return 반환타입과_일치하는_유형의_표현식;
            }
            접근제한자 set
            {
                //인덱스 식별자로 구분되는 값에 value 를 대입;
            }
        }
    }
```